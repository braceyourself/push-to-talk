<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Push-to-Talk Live Dashboard</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; color: #e0e0e0; font-family: system-ui, -apple-system, sans-serif; height: 100vh; overflow: hidden; }

  /* ── Header ── */
  .header {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 20px; background: #16213e; border-bottom: 1px solid #0f3460;
  }
  .header h1 { font-size: 1.1em; font-weight: 600; }
  .header-right { display: flex; align-items: center; gap: 16px; font-size: 13px; color: #888; }
  .conn-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }
  .conn-dot.connected { background: #4ade80; box-shadow: 0 0 6px #4ade80; }
  .conn-dot.disconnected { background: #ef4444; box-shadow: 0 0 6px #ef4444; }
  .gen-id { font-family: monospace; color: #a78bfa; }

  /* ── Layout ── */
  .main { display: grid; grid-template-rows: auto 1fr; height: calc(100vh - 46px); }

  /* ── Pipeline Row ── */
  .pipeline-row {
    display: flex; align-items: center; justify-content: center; gap: 0;
    padding: 16px 12px; background: #16213e40; flex-wrap: nowrap;
    overflow-x: auto; min-height: 0;
  }
  .stage-node {
    display: flex; flex-direction: column; align-items: center; gap: 4px;
    padding: 10px 12px; border-radius: 10px; border: 2px solid; min-width: 80px;
    position: relative; flex-shrink: 0;
    transition: background 0.3s, border-color 0.3s, box-shadow 0.3s;
    background: transparent;
  }
  .stage-node.active {
    background: var(--bg-active);
    box-shadow: 0 0 20px var(--glow), inset 0 0 12px var(--glow);
    border-color: var(--color-bright);
  }
  .stage-node.active .stage-name { color: #fff; }
  .stage-node.active .stage-detail { color: #ccc; }
  .stage-name { font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; transition: color 0.3s; }
  .stage-detail { font-size: 11px; color: #888; font-family: monospace; transition: color 0.3s; }

  .node-mic { border-color: #4ade8060; --color-bright: #4ade80; --bg-active: #4ade8025; --glow: #4ade8040; }
  .node-stt { border-color: #60a5fa60; --color-bright: #60a5fa; --bg-active: #60a5fa25; --glow: #60a5fa40; }
  .node-llm { border-color: #a78bfa60; --color-bright: #a78bfa; --bg-active: #a78bfa25; --glow: #a78bfa40; }
  .node-composer { border-color: #f59e0b60; --color-bright: #f59e0b; --bg-active: #f59e0b25; --glow: #f59e0b40; }
  .node-playback { border-color: #ec489960; --color-bright: #ec4899; --bg-active: #ec489925; --glow: #ec489940; }

  .queue-pill {
    display: flex; align-items: center; justify-content: center;
    padding: 2px 6px; margin: 0 2px; font-size: 10px; font-family: monospace;
    border-radius: 8px; background: #1a1a2e; border: 1px solid #333; min-width: 24px; flex-shrink: 0;
  }
  .queue-pill.low { border-color: #4ade80; color: #4ade80; }
  .queue-pill.mid { border-color: #f59e0b; color: #f59e0b; }
  .queue-pill.high { border-color: #ef4444; color: #ef4444; }
  .arrow { color: #555; font-size: 14px; margin: 0 1px; flex-shrink: 0; }

  /* ── RMS Meter ── */
  .rms-meter { display: flex; align-items: flex-end; gap: 2px; height: 24px; margin-top: 4px; }
  .rms-bar { width: 6px; background: #4ade80; border-radius: 2px 2px 0 0; transition: height 80ms ease-out; min-height: 2px; }

  /* ── Bottom Section ── */
  .bottom { display: grid; grid-template-columns: 340px 1fr; gap: 0; overflow: hidden; }

  /* ── Metrics Panel ── */
  .metrics { padding: 16px; display: flex; flex-direction: column; gap: 12px; border-right: 1px solid #0f3460; overflow-y: auto; }
  .metric-card {
    background: #16213e; border-radius: 8px; padding: 12px 14px; border: 1px solid #0f3460;
  }
  .metric-label { font-size: 11px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 4px; }
  .metric-value { font-size: 28px; font-weight: 700; font-family: monospace; }
  .metric-value.stt-color { color: #60a5fa; }
  .metric-value.llm-color { color: #a78bfa; }
  .metric-value.tts-color { color: #f59e0b; }
  .sparkline { margin-top: 6px; }
  .sparkline svg { display: block; }

  /* ── Status indicator ── */
  .status-card {
    background: #16213e; border-radius: 8px; padding: 10px 14px; border: 1px solid #0f3460;
    display: flex; align-items: center; gap: 10px;
  }
  .status-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
  .status-dot.listening { background: #4ade80; }
  .status-dot.thinking { background: #a78bfa; animation: blink 1s ease-in-out infinite; }
  .status-dot.speaking { background: #f59e0b; }
  .status-dot.muted { background: #ef4444; }
  .status-dot.tool_use { background: #60a5fa; }
  .status-dot.idle { background: #555; }
  @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }
  .status-text { font-size: 14px; font-weight: 600; text-transform: capitalize; }

  /* ── Event Log ── */
  .event-log { display: flex; flex-direction: column; overflow: hidden; }
  .log-header { padding: 12px 16px; font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #0f3460; flex-shrink: 0; }
  .log-content {
    flex: 1; overflow-y: auto; padding: 8px 16px; font-family: monospace; font-size: 12px;
    line-height: 1.6;
  }
  .log-content::-webkit-scrollbar { width: 6px; }
  .log-content::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
  .log-entry { white-space: nowrap; }
  .log-ts { color: #555; }
  .log-type { font-weight: 600; }
  .log-type.status { color: #4ade80; }
  .log-type.audio_rms { color: #4ade8080; }
  .log-type.stt_start, .log-type.stt_complete { color: #60a5fa; }
  .log-type.llm_send, .log-type.llm_first_token, .log-type.llm_text_delta, .log-type.llm_complete { color: #a78bfa; }
  .log-type.llm_tool_use { color: #60a5fa; }
  .log-type.tts_start, .log-type.tts_complete { color: #f59e0b; }
  .log-type.filler_played { color: #ec4899; }
  .log-type.barge_in { color: #ef4444; }
  .log-type.queue_depths { color: #55555580; }
  .log-type.snapshot { color: #888; }
  .log-data { color: #888; }
</style>
</head>
<body>
<div class="header">
  <h1>Push-to-Talk Live Pipeline</h1>
  <div class="header-right">
    <span><span class="conn-dot disconnected" id="connDot"></span> <span id="connLabel">Disconnected</span></span>
    <span>gen: <span class="gen-id" id="genId">-</span></span>
  </div>
</div>

<div class="main">
  <!-- Pipeline Flow -->
  <div class="pipeline-row">
    <div class="stage-node node-mic" id="nodeMic">
      <div class="stage-name">Mic</div>
      <div class="rms-meter" id="rmsMeter"></div>
      <div class="stage-detail" id="micDetail">-</div>
    </div>
    <span class="arrow">&rarr;</span>
    <div class="queue-pill low" id="qAudioIn">0</div>
    <span class="arrow">&rarr;</span>
    <div class="stage-node node-stt" id="nodeStt">
      <div class="stage-name">STT</div>
      <div class="stage-detail" id="sttDetail">-</div>
    </div>
    <span class="arrow">&rarr;</span>
    <div class="queue-pill low" id="qSttOut">0</div>
    <span class="arrow">&rarr;</span>
    <div class="stage-node node-llm" id="nodeLlm">
      <div class="stage-name">LLM</div>
      <div class="stage-detail" id="llmDetail">-</div>
    </div>
    <span class="arrow">&rarr;</span>
    <div class="queue-pill low" id="qComposer">0</div>
    <span class="arrow">&rarr;</span>
    <div class="stage-node node-composer" id="nodeComposer">
      <div class="stage-name">Composer</div>
      <div class="stage-detail" id="composerDetail">-</div>
    </div>
    <span class="arrow">&rarr;</span>
    <div class="queue-pill low" id="qAudioOut">0</div>
    <span class="arrow">&rarr;</span>
    <div class="stage-node node-playback" id="nodePlayback">
      <div class="stage-name">Playback</div>
      <div class="stage-detail" id="playbackDetail">-</div>
    </div>
  </div>

  <!-- Bottom: Metrics + Event Log -->
  <div class="bottom">
    <div class="metrics">
      <div class="status-card">
        <div class="status-dot idle" id="statusDot"></div>
        <div class="status-text" id="statusText">Idle</div>
      </div>
      <div class="metric-card">
        <div class="metric-label">STT Latency</div>
        <div class="metric-value stt-color" id="metricStt">- ms</div>
        <div class="sparkline" id="sparkStt"></div>
      </div>
      <div class="metric-card">
        <div class="metric-label">First Token</div>
        <div class="metric-value llm-color" id="metricLlm">- ms</div>
        <div class="sparkline" id="sparkLlm"></div>
      </div>
      <div class="metric-card">
        <div class="metric-label">TTS Latency</div>
        <div class="metric-value tts-color" id="metricTts">- ms</div>
        <div class="sparkline" id="sparkTts"></div>
      </div>
    </div>
    <div class="event-log">
      <div class="log-header">Event Log</div>
      <div class="log-content" id="logContent"></div>
    </div>
  </div>
</div>

<script>
(function() {
  'use strict';

  // ── State ──
  let es = null;
  const MAX_LOG = 200;
  const SPARK_LEN = 20;
  const sttLatencies = [], llmLatencies = [], ttsLatencies = [];
  let logCount = 0;

  // ── DOM refs ──
  const $ = id => document.getElementById(id);
  const connDot = $('connDot'), connLabel = $('connLabel'), genId = $('genId');
  const logContent = $('logContent');
  const rmsMeter = $('rmsMeter');

  // Build RMS bars
  for (let i = 0; i < 8; i++) {
    const bar = document.createElement('div');
    bar.className = 'rms-bar';
    bar.style.height = '2px';
    rmsMeter.appendChild(bar);
  }

  // ── Queue pill helpers ──
  function updateQueuePill(id, val) {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
    el.className = 'queue-pill ' + (val > 20 ? 'high' : val > 5 ? 'mid' : 'low');
  }

  // ── Sparkline renderer ──
  function renderSparkline(containerId, values, color) {
    const el = $(containerId);
    if (!el || values.length < 2) return;
    const w = 280, h = 30;
    const max = Math.max(...values, 1);
    const pts = values.map((v, i) => {
      const x = (i / (SPARK_LEN - 1)) * w;
      const y = h - (v / max) * (h - 4) - 2;
      return `${x},${y}`;
    });
    el.innerHTML = `<svg width="${w}" height="${h}" viewBox="0 0 ${w} ${h}">
      <polyline points="${pts.join(' ')}" fill="none" stroke="${color}" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>`;
  }

  // ── Activate node (pulse) ──
  // Track per-node timeout handles so we can extend/clear
  const nodeTimers = {};
  function activateNode(id, ms) {
    const el = $(id);
    if (!el) return;
    el.classList.add('active');
    if (nodeTimers[id]) clearTimeout(nodeTimers[id]);
    nodeTimers[id] = setTimeout(() => { el.classList.remove('active'); nodeTimers[id] = null; }, ms || 2000);
  }
  function deactivateAllNodes() {
    for (const id of ['nodeMic','nodeStt','nodeLlm','nodeComposer','nodePlayback']) {
      const el = $(id);
      if (el) el.classList.remove('active');
      if (nodeTimers[id]) { clearTimeout(nodeTimers[id]); nodeTimers[id] = null; }
    }
  }
  // Set the primary active stage based on pipeline status
  function setPipelineStage(status) {
    deactivateAllNodes();
    if (status === 'listening') activateNode('nodeMic', 60000);
    else if (status === 'thinking') activateNode('nodeLlm', 60000);
    else if (status === 'speaking') { activateNode('nodeComposer', 60000); activateNode('nodePlayback', 60000); }
    else if (status === 'tool_use') activateNode('nodeLlm', 60000);
    else if (status === 'muted') {} // nothing lit
  }

  // ── Status update ──
  function setStatus(status) {
    const dot = $('statusDot'), text = $('statusText');
    dot.className = 'status-dot ' + (status || 'idle');
    text.textContent = status || 'idle';
  }

  // ── Log entry ──
  function addLog(event) {
    const t = new Date(event.ts * 1000);
    const ts = t.toLocaleTimeString('en-US', { hour12: false }) + '.' + String(t.getMilliseconds()).padStart(3, '0');

    let detail = '';
    const skip = new Set(['type', 'ts', 'gen_id']);
    for (const [k, v] of Object.entries(event)) {
      if (skip.has(k)) continue;
      const sv = typeof v === 'string' ? v : JSON.stringify(v);
      if (sv.length > 80) detail += ` ${k}=${sv.substring(0, 77)}...`;
      else detail += ` ${k}=${sv}`;
    }

    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.innerHTML = `<span class="log-ts">${ts}</span> <span class="log-type ${event.type}">${event.type}</span><span class="log-data">${detail}</span>`;
    logContent.appendChild(entry);
    logCount++;
    if (logCount > MAX_LOG) {
      logContent.removeChild(logContent.firstChild);
      logCount--;
    }
    logContent.scrollTop = logContent.scrollHeight;
  }

  // ── Event handlers ──
  const handlers = {
    snapshot(e) {
      genId.textContent = e.gen_id;
      setStatus(e.muted ? 'muted' : 'idle');
      if (e.queue_depths) {
        updateQueuePill('qAudioIn', e.queue_depths.audio_in || 0);
        updateQueuePill('qSttOut', e.queue_depths.stt_out || 0);
        updateQueuePill('qComposer', e.queue_depths.composer || 0);
        updateQueuePill('qAudioOut', e.queue_depths.audio_out || 0);
      }
    },
    status(e) {
      setStatus(e.status);
      setPipelineStage(e.status);
    },
    audio_rms(e) {
      const bars = rmsMeter.children;
      const rms = e.rms || 0;
      // Distribute RMS across 8 bars with some randomness for visual appeal
      for (let i = 0; i < bars.length; i++) {
        const factor = 0.5 + Math.random() * 0.5;
        const h = Math.min(24, Math.max(2, (rms / 500) * 24 * factor));
        bars[i].style.height = h + 'px';
        bars[i].style.background = rms > 200 ? '#4ade80' : rms > 100 ? '#60a5fa' : '#555';
      }
      $('micDetail').textContent = `RMS: ${Math.round(rms)}`;
      activateNode('nodeMic', 300);
    },
    stt_start(e) {
      $('sttDetail').textContent = `${e.trigger || ''} ${(e.buf_seconds || 0).toFixed(1)}s`;
      activateNode('nodeStt', 2000);
    },
    stt_complete(e) {
      const ms = e.latency_ms;
      if (ms != null) {
        $('metricStt').textContent = Math.round(ms) + ' ms';
        sttLatencies.push(ms);
        if (sttLatencies.length > SPARK_LEN) sttLatencies.shift();
        renderSparkline('sparkStt', sttLatencies, '#60a5fa');
      }
      if (e.text) $('sttDetail').textContent = e.text.substring(0, 30);
    },
    llm_send(e) {
      $('llmDetail').textContent = (e.text_preview || '').substring(0, 30);
      activateNode('nodeLlm', 5000);
    },
    llm_first_token(e) {
      const ms = e.latency_ms;
      if (ms != null) {
        $('metricLlm').textContent = Math.round(ms) + ' ms';
        llmLatencies.push(ms);
        if (llmLatencies.length > SPARK_LEN) llmLatencies.shift();
        renderSparkline('sparkLlm', llmLatencies, '#a78bfa');
      }
    },
    llm_text_delta(e) {
      $('llmDetail').textContent = `${e.total_chars || 0} chars`;
    },
    llm_tool_use(e) {
      $('llmDetail').textContent = e.intent || e.tool_name || 'tool';
      activateNode('nodeLlm', 3000);
    },
    llm_complete(e) {
      $('llmDetail').textContent = `${e.total_chars || 0}c / ${e.sentences || 0}s`;
    },
    tts_start(e) {
      $('composerDetail').textContent = (e.text || '').substring(0, 20);
      activateNode('nodeComposer', 2000);
    },
    tts_complete(e) {
      const ms = e.latency_ms;
      if (ms != null) {
        $('metricTts').textContent = Math.round(ms) + ' ms';
        ttsLatencies.push(ms);
        if (ttsLatencies.length > SPARK_LEN) ttsLatencies.shift();
        renderSparkline('sparkTts', ttsLatencies, '#f59e0b');
      }
    },
    filler_played(e) {
      $('composerDetail').textContent = e.sufficient ? 'filler (suff)' : 'filler';
      activateNode('nodeComposer', 1000);
    },
    barge_in(e) {
      $('playbackDetail').textContent = `barge ${e.spoken_sentences || 0}/${e.total_sentences || 0}`;
      activateNode('nodePlayback', 2000);
    },
    queue_depths(e) {
      updateQueuePill('qAudioIn', e.audio_in || 0);
      updateQueuePill('qSttOut', e.stt_out || 0);
      updateQueuePill('qComposer', e.composer || 0);
      updateQueuePill('qAudioOut', e.audio_out || 0);
    },
  };

  function handleEvent(event) {
    genId.textContent = event.gen_id;
    const fn = handlers[event.type];
    if (fn) fn(event);
    // Don't log queue_depths to reduce noise
    if (event.type !== 'queue_depths') {
      addLog(event);
    }
  }

  // ── SSE Connection ──
  function connect() {
    if (es) { es.close(); es = null; }
    es = new EventSource('http://127.0.0.1:9847/events');

    es.onopen = () => {
      connDot.className = 'conn-dot connected';
      connLabel.textContent = 'Connected';
    };

    es.onmessage = (ev) => {
      try {
        const event = JSON.parse(ev.data);
        handleEvent(event);
      } catch (err) {
        console.warn('SSE parse error:', err);
      }
    };

    es.onerror = () => {
      connDot.className = 'conn-dot disconnected';
      connLabel.textContent = 'Reconnecting...';
      es.close();
      es = null;
      setTimeout(connect, 2000);
    };
  }

  // ── Init ──
  connect();

  // Decay RMS bars when no events
  setInterval(() => {
    const bars = rmsMeter.children;
    for (let i = 0; i < bars.length; i++) {
      const h = parseFloat(bars[i].style.height) || 2;
      if (h > 2) bars[i].style.height = Math.max(2, h * 0.85) + 'px';
    }
  }, 200);
})();
</script>
</body>
</html>
