---
phase: 02-async-task-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - task_manager.py
  - test_task_manager.py
autonomous: true

must_haves:
  truths:
    - "TaskManager can spawn a Claude CLI task that runs asynchronously without blocking the event loop"
    - "TaskManager tracks each task's id, name, status, process handle, and captured output"
    - "Only one task can run per project directory at a time"
    - "Completed and failed tasks are cleaned up after retrieval (process reaped, references released)"
    - "No zombie Claude CLI processes accumulate during normal operation or after failures"
    - "Task output is streamed line-by-line into a capped ring buffer and persisted to disk on completion"
  artifacts:
    - path: "task_manager.py"
      provides: "TaskManager singleton, ClaudeTask dataclass, TaskStatus enum"
      contains: "class TaskManager"
    - path: "task_manager.py"
      provides: "Async subprocess spawn with strong references"
      contains: "create_subprocess_exec"
    - path: "task_manager.py"
      provides: "Graceful process termination with SIGTERM/SIGKILL escalation"
      contains: "os.killpg"
    - path: "task_manager.py"
      provides: "Callback/event system for task lifecycle"
      contains: "on_task_complete"
    - path: "test_task_manager.py"
      provides: "Integration test proving spawn, track, cancel, cleanup lifecycle"
      contains: "asyncio.run"
  key_links:
    - from: "task_manager.py:TaskManager.spawn_task"
      to: "task_manager.py:TaskManager._run_task"
      via: "asyncio.create_task with strong reference in _active_tasks set"
      pattern: "_active_tasks\\.add"
    - from: "task_manager.py:TaskManager._run_task"
      to: "asyncio.create_subprocess_exec"
      via: "Claude CLI process creation with start_new_session=True"
      pattern: "start_new_session=True"
    - from: "task_manager.py:TaskManager.cancel_task"
      to: "task_manager.py:TaskManager._terminate_process"
      via: "SIGTERM to process group, escalate to SIGKILL after 5s"
      pattern: "killpg.*SIGTERM"
    - from: "task_manager.py:TaskManager._run_task"
      to: "task_manager.py:TaskManager._fire_callbacks"
      via: "Event dispatch on completion, failure, and per-line output"
      pattern: "_fire_callbacks"
---

<objective>
Implement TaskManager singleton and ClaudeTask dataclass for non-blocking Claude CLI subprocess management.

Purpose: Provide the async task infrastructure that Phase 3 will wire into the live voice session for voice-controlled task orchestration. This is a standalone module with no dependencies on existing code -- it creates the building block.

Output: `task_manager.py` containing TaskStatus enum, ClaudeTask dataclass, and TaskManager class with full async subprocess lifecycle management. Plus `test_task_manager.py` integration test proving the lifecycle works end-to-end.
</objective>

<execution_context>
@/home/ethan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ethan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-async-task-infrastructure/02-CONTEXT.md
@.planning/phases/02-async-task-infrastructure/02-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create task_manager.py with TaskManager, ClaudeTask, and full async lifecycle</name>
  <files>task_manager.py</files>
  <action>
Create `task_manager.py` in the project root (alongside `push-to-talk.py`, `live_session.py`, etc.).

This file contains three main components:

**1. TaskStatus enum** with values: PENDING, RUNNING, COMPLETED, FAILED, CANCELLED.

**2. ClaudeTask dataclass** with fields:
- `id: int` -- auto-incrementing integer assigned by TaskManager
- `name: str` -- human-friendly name (set by caller, Phase 3 derives from voice request)
- `prompt: str` -- the prompt passed to Claude CLI via `-p`
- `project_dir: Path` -- directory where Claude CLI runs (cwd)
- `status: TaskStatus` -- defaults to PENDING
- `process: Optional[asyncio.subprocess.Process]` -- the subprocess handle (repr=False)
- `_asyncio_task: Optional[asyncio.Task]` -- strong reference to the asyncio task (repr=False)
- `output_lines: deque` -- ring buffer with `maxlen=1000` (~200KB cap)
- `created_at: float` -- `time.time()` at creation
- `started_at: Optional[float]` -- set when process starts
- `completed_at: Optional[float]` -- set when process exits
- `return_code: Optional[int]` -- process exit code

**3. TaskManager class** (singleton pattern) with:

**Singleton:**
- `_instance` class variable, `__new__` checks and creates once
- `__init__` guards with `_initialized` flag to prevent re-init
- Instance state: `_tasks: dict[int, ClaudeTask]`, `_next_id: int = 1`, `_active_tasks: set[asyncio.Task]`, `_project_locks: dict[str, int]` (resolved project_dir string -> task_id), `_callbacks: dict[str, list[Callable]]`

**Callback events:** `on_task_complete`, `on_task_failed`, `on_output_line`

**Core methods:**

`async def spawn_task(self, name: str, prompt: str, project_dir: Path) -> ClaudeTask`:
- Enforce one-per-project: resolve `project_dir`, check `_project_locks` for a RUNNING task in that dir. Raise `ValueError` if conflict.
- Create ClaudeTask with next ID, increment `_next_id`.
- Store in `_tasks` and `_project_locks`.
- Create asyncio task via `asyncio.create_task(self._run_task(task))` with name `f"claude-task-{task.id}"`.
- Store reference: `task._asyncio_task = asyncio_task`, add to `_active_tasks`, register `add_done_callback(self._active_tasks.discard)`.
- Return the ClaudeTask.

`async def _run_task(self, task: ClaudeTask) -> None`:
- Set status to RUNNING, record `started_at`.
- Build command: `[str(Path.home() / '.local' / 'bin' / 'claude'), '-p', task.prompt, '--no-session-persistence', '--permission-mode', 'bypassPermissions', '--output-format', 'text']`.
- Create subprocess with `asyncio.create_subprocess_exec(*cmd, stdout=PIPE, stderr=STDOUT, cwd=str(task.project_dir), start_new_session=True)`.
- Stream output: `while True: line = await task.process.stdout.readline(); if not line: break; decode UTF-8; append to task.output_lines; fire on_output_line callback`.
- After loop: `await task.process.wait()` to reap. Set `return_code`, `completed_at`.
- If return_code == 0: status = COMPLETED, fire `on_task_complete`. Else: status = FAILED, fire `on_task_failed`.
- Persist output to disk via `_persist_output(task)`.
- On `asyncio.CancelledError`: set status CANCELLED, call `_terminate_process(task)`, re-raise.
- On unexpected Exception: set status FAILED, append error message to output_lines, fire `on_task_failed`.
- In `finally` block: release project lock (`del _project_locks[dir_key]` if it matches this task_id), and ensure `await task.process.wait()` is called if process exists and hasn't been reaped (prevent zombies).

`async def cancel_task(self, task_id: int) -> bool`:
- Look up task. Return False if not found or not RUNNING.
- Set status CANCELLED, `completed_at = time.time()`.
- Cancel the asyncio task if not done.
- Call `_terminate_process(task)`.
- Release project lock.
- Return True.

`async def _terminate_process(self, task: ClaudeTask) -> None`:
- Guard: return if process is None or returncode is not None (already dead).
- Get process group ID via `os.getpgid(task.process.pid)`.
- Send `SIGTERM` to process group via `os.killpg(pgid, signal.SIGTERM)`.
- Wait up to 5 seconds: `await asyncio.wait_for(task.process.wait(), timeout=5.0)`.
- On timeout: `os.killpg(pgid, signal.SIGKILL)`, then `await task.process.wait()`.
- Catch `ProcessLookupError` (already dead).

**Query methods:**
- `get_task(task_id: int) -> Optional[ClaudeTask]` -- lookup by ID
- `find_task_by_name(name: str) -> Optional[ClaudeTask]` -- case-insensitive partial match
- `get_all_tasks() -> list[ClaudeTask]` -- all tasks, newest first
- `get_running_tasks() -> list[ClaudeTask]` -- only RUNNING status
- `get_task_output(task_id: int) -> Optional[str]` -- join output_lines with newlines

**Cleanup:**
- `cleanup_task(task_id: int) -> bool` -- remove completed/failed/cancelled task from `_tasks` and `_project_locks`. Return False if task is RUNNING (can't cleanup running task).

**Event system:**
- `on(event: str, callback: Callable) -> None` -- register callback. Raise ValueError for unknown event name.
- `async def _fire_callbacks(self, event: str, *args) -> None` -- iterate callbacks, call each. If result is a coroutine, await it. Catch and log exceptions per-callback (never let a bad callback crash the task).

**Output persistence:**
- `async def _persist_output(self, task: ClaudeTask) -> None` -- write task output to `{project_dir}/.claude-tasks/task-{id}-output.md`. Create `.claude-tasks/` dir if needed. Include task metadata (name, status, project, timestamps, duration) and full output in a markdown code block.

**Follow existing codebase conventions:**
- Module docstring at top explaining purpose
- `print(..., flush=True)` for all logging (systemd journal)
- snake_case functions, PascalCase classes, UPPERCASE constants
- No type hints in signatures (codebase doesn't use them -- BUT the RESEARCH.md patterns use them and they improve clarity here since this is a new standalone module. Use type hints for this file since it's a self-contained API that Phase 3 will consume.)
- pathlib.Path for all path handling
- Graceful error handling (try/except with logging, no crashes)

**Important: Do NOT use `asyncio.TaskGroup`** -- it waits for all tasks on exit and cancels remaining on exception. Use `create_task()` with strong reference set instead.

**Claude CLI binary path:** `Path.home() / '.local' / 'bin' / 'claude'` (verified installed at this location, v2.1.42).
  </action>
  <verify>
Run `python3 -c "from task_manager import TaskManager, ClaudeTask, TaskStatus; tm = TaskManager(); print('Import OK, singleton:', tm is TaskManager())"` and confirm it prints "Import OK, singleton: True" with no import errors.

Run `python3 -c "import ast; ast.parse(open('task_manager.py').read()); print('Syntax OK')"` to verify no syntax errors.

Verify the file contains all required components:
- `grep -c 'class TaskStatus' task_manager.py` returns 1
- `grep -c 'class ClaudeTask' task_manager.py` returns 1
- `grep -c 'class TaskManager' task_manager.py` returns 1
- `grep -c 'async def spawn_task' task_manager.py` returns 1
- `grep -c 'async def cancel_task' task_manager.py` returns 1
- `grep -c 'async def _run_task' task_manager.py` returns 1
- `grep -c 'async def _terminate_process' task_manager.py` returns 1
- `grep -c 'start_new_session=True' task_manager.py` returns 1
- `grep -c 'os.killpg' task_manager.py` returns at least 1
- `grep -c '_active_tasks' task_manager.py` returns at least 2
- `grep -c 'deque(maxlen=' task_manager.py` returns at least 1
- `grep -c '_persist_output' task_manager.py` returns at least 1
  </verify>
  <done>
task_manager.py exists in project root with TaskStatus enum (5 values), ClaudeTask dataclass (12 fields), and TaskManager singleton class. TaskManager has: spawn_task (with one-per-project enforcement), _run_task (async subprocess with line-by-line streaming), cancel_task (with SIGTERM/SIGKILL escalation), _terminate_process, get_task, find_task_by_name, get_all_tasks, get_running_tasks, get_task_output, cleanup_task, on (callback registration), _fire_callbacks, and _persist_output. All methods use asyncio.create_subprocess_exec (not subprocess.run), strong references prevent GC, start_new_session=True enables process group cleanup, and output is capped with deque(maxlen=1000).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test proving full task lifecycle</name>
  <files>test_task_manager.py</files>
  <action>
Create `test_task_manager.py` in the project root. This is a standalone integration test script (not pytest, since the project has no test framework). It runs with `python3 test_task_manager.py` and exercises the full TaskManager lifecycle using a simple shell command (NOT Claude CLI -- we test the machinery, not the CLI itself).

The test overrides the Claude CLI command to use a simple echo script, proving the async machinery works without requiring Claude CLI to be available or burning API credits.

**Test structure:**

```python
#!/usr/bin/env python3
"""Integration tests for TaskManager async subprocess lifecycle."""
import asyncio
import sys
import os
import tempfile
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

from task_manager import TaskManager, ClaudeTask, TaskStatus
```

**Helper:** Monkey-patch `TaskManager._build_claude_command` (or equivalent) to return a test command instead of the real Claude CLI. The test command should be something like `['python3', '-c', 'import time; [print(f"line {i}", flush=True) or time.sleep(0.1) for i in range(10)]; print("done", flush=True)']` -- this produces 11 lines of output over ~1 second.

**Tests to implement (as async functions, run via asyncio.run):**

1. **test_spawn_and_complete**: Spawn a task, wait for completion, verify status is COMPLETED, output_lines has content, return_code is 0, started_at and completed_at are set.

2. **test_singleton**: Verify `TaskManager()` returns the same instance (is-check).

3. **test_one_per_project**: Spawn a long-running task in dir A. Try to spawn another in dir A. Verify ValueError is raised. Spawn in dir B succeeds (different directory).

4. **test_cancel_task**: Spawn a long-running task (sleep 30). Cancel it. Verify status is CANCELLED. Verify process is dead (no zombie). Verify project lock is released.

5. **test_callbacks**: Register `on_task_complete` callback. Spawn task. Wait for completion. Verify callback was called with the task.

6. **test_output_streaming**: Register `on_output_line` callback that collects lines. Spawn task that prints lines. Wait for completion. Verify collected lines match expected output.

7. **test_query_methods**: Spawn a task. Verify `get_task(id)` returns it. Verify `find_task_by_name(partial)` finds it. Verify `get_all_tasks()` includes it. Verify `get_running_tasks()` includes it while running.

8. **test_cleanup**: Spawn task, wait for completion. Call `cleanup_task(id)`. Verify `get_task(id)` returns None. Verify project lock released.

9. **test_output_persistence**: Spawn task in a temp directory. Wait for completion. Verify `.claude-tasks/task-{id}-output.md` file exists and contains task output.

10. **test_failed_task**: Spawn a task with a command that exits non-zero (`sys.exit(1)`). Wait for completion. Verify status is FAILED and return_code is 1.

**Runner:** Each test function is called sequentially. Print pass/fail for each. Reset TaskManager singleton between tests (set `TaskManager._instance = None` and delete any cached state). Use temporary directories for project_dir (via tempfile.mkdtemp). Clean up temp dirs after each test.

**Exit code:** 0 if all pass, 1 if any fail.

**Important:** The test must handle the TaskManager singleton reset correctly between tests. Since TaskManager uses `_initialized` flag, reset both `_instance = None` and clear the flag. A helper function `reset_task_manager()` should handle this:
```python
def reset_task_manager():
    TaskManager._instance = None
    # Next __init__ will re-initialize
```

**Important:** For the one-per-project test and cancel test, use a long-running command like `['python3', '-c', 'import time; time.sleep(30)']` so the task is still RUNNING when we test against it.

**Important:** After cancel tests, allow a brief sleep (0.5s) for process cleanup to complete before asserting.
  </action>
  <verify>
Run `python3 test_task_manager.py` from the project root. All tests should pass with output like:
```
test_spawn_and_complete: PASS
test_singleton: PASS
test_one_per_project: PASS
test_cancel_task: PASS
test_callbacks: PASS
test_output_streaming: PASS
test_query_methods: PASS
test_cleanup: PASS
test_output_persistence: PASS
test_failed_task: PASS

10/10 tests passed
```

Exit code should be 0.

Also verify no zombie processes remain: `ps aux | grep defunct | grep -v grep` should show nothing new.
  </verify>
  <done>
test_task_manager.py runs 10 integration tests covering: spawn-to-completion lifecycle, singleton pattern, one-per-project enforcement, task cancellation with process cleanup, callback dispatch (on_task_complete and on_output_line), query methods (get_task, find_task_by_name, get_all_tasks, get_running_tasks), cleanup_task memory release, output file persistence, and failed task handling. All tests pass. No zombie processes remain after tests.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full requirements matrix:

- INFRA-01 (async tool execution): TaskManager.spawn_task() is async and uses asyncio.create_subprocess_exec() -- the async execution path is ready for Phase 3 to call from tool handlers. (The actual wiring of execute_tool() happens in Phase 3.)
- INFRA-02 (task tracking): TaskManager._tasks dict tracks id, name, process, status, start_time, stdout. Verified by test_spawn_and_complete and test_query_methods.
- INFRA-03 (working directory): Tasks run in target project directory (cwd=project_dir) with one-per-project enforcement. Verified by test_one_per_project.
- INFRA-04 (Claude CLI flags): _build_claude_command uses `-p`, `--no-session-persistence`, `--permission-mode bypassPermissions`, `--output-format text`. Verified by grep.
- INFRA-05 (strong references): _active_tasks set + add_done_callback(discard) pattern. Verified by grep and test_spawn_and_complete (task runs to completion without GC).
- INFRA-06 (process cleanup): _terminate_process with SIGTERM/SIGKILL escalation, process.wait() in finally block, project lock release. Verified by test_cancel_task and test_cleanup.

Run: `grep -c 'create_subprocess_exec' task_manager.py` -- must be >= 1
Run: `grep -c 'start_new_session=True' task_manager.py` -- must be >= 1
Run: `grep -c '_active_tasks' task_manager.py` -- must be >= 2
Run: `grep -c 'killpg' task_manager.py` -- must be >= 1
Run: `python3 test_task_manager.py` -- all tests pass
</verification>

<success_criteria>
1. `task_manager.py` exists and imports cleanly with no errors
2. TaskManager is a singleton (same instance on repeated instantiation)
3. spawn_task() creates async subprocess that streams output without blocking
4. One-per-project enforcement prevents concurrent tasks in same directory
5. cancel_task() terminates process group cleanly (no zombies)
6. Callback system dispatches on_task_complete, on_task_failed, on_output_line
7. Output persisted to `.claude-tasks/task-{id}-output.md` on completion
8. cleanup_task() releases all references and project locks
9. All 10 integration tests pass with exit code 0
</success_criteria>

<output>
After completion, create `.planning/phases/02-async-task-infrastructure/02-01-SUMMARY.md`
</output>
