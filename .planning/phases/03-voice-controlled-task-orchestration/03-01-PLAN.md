---
phase: 03-voice-controlled-task-orchestration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - live_session.py
  - push-to-talk.py
autonomous: true

must_haves:
  truths:
    - "User can say 'ask Claude to refactor the auth module' and a background task spawns while conversation continues"
    - "User can ask 'what are my tasks doing?' and hear a status summary"
    - "User can say 'cancel the auth task' and the task terminates"
    - "User can ask 'what did the auth task produce?' and hear a summary of the output"
    - "Tool calls execute asynchronously without blocking the WebSocket event loop"
  artifacts:
    - path: "live_session.py"
      provides: "TASK_TOOLS list, _execute_tool method, function_call handler in response.done"
      contains: "TASK_TOOLS"
    - path: "push-to-talk.py"
      provides: "TaskManager initialization wired into live session lifecycle"
      contains: "TaskManager"
  key_links:
    - from: "live_session.py"
      to: "task_manager.py"
      via: "TaskManager() singleton import and method calls"
      pattern: "from task_manager import TaskManager"
    - from: "live_session.py (response.done handler)"
      to: "live_session.py (_execute_tool)"
      via: "function_call item detection in output_items"
      pattern: "function_call"
    - from: "live_session.py (_execute_tool)"
      to: "task_manager.py (spawn_task, cancel_task, get_all_tasks, get_task_output)"
      via: "async method calls on TaskManager singleton"
      pattern: "self\\.task_manager\\."
---

<objective>
Add Realtime API tool definitions for task management and wire the function call handler into LiveSession so users can spawn, query, cancel, and retrieve results from Claude CLI tasks by voice.

Purpose: This is the core integration between the voice session (Phase 1) and the task infrastructure (Phase 2). Without tool definitions, the AI cannot act on task-related requests. Without the handler, tool calls go unprocessed.

Output: LiveSession with 5 task management tools (spawn_task, list_tasks, get_task_status, get_task_result, cancel_task) and a working function_call handler that routes tool calls to TaskManager methods and returns results to the conversation.
</objective>

<execution_context>
@/home/ethan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ethan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-controlled-task-orchestration/03-RESEARCH.md
@.planning/phases/02-async-task-infrastructure/02-01-SUMMARY.md
@.planning/phases/01-mode-rename-and-live-voice-session/01-02-SUMMARY.md
@live_session.py
@task_manager.py
@openai_realtime.py
@push-to-talk.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add task management tool definitions and function call handler to LiveSession</name>
  <files>live_session.py</files>
  <action>
  1. Add imports at top of live_session.py:
     ```python
     from task_manager import TaskManager, ClaudeTask, TaskStatus
     ```

  2. Define TASK_TOOLS list as a module-level constant (above the LiveSession class). Define 5 tools:

     - `spawn_task`: Start a Claude CLI task in the background. Parameters: `name` (string, "Short descriptive name, 2-4 words"), `prompt` (string, "Detailed prompt for Claude CLI to execute"), `project_dir` (string, "Absolute path to the project directory where Claude should work"). Description must emphasize: "Use when the user asks you to do real work -- coding, refactoring, debugging, analysis. Return immediately with a brief acknowledgment. Keep acknowledgments short, every word takes time to speak."

     - `list_tasks`: List all tasks with their current status. No parameters. Description: "Use when the user asks what tasks are running or wants a status update. Summarize concisely -- every word costs time to speak aloud."

     - `get_task_status`: Get detailed status of a specific task. Parameters: `identifier` (string, "Task name, partial name, or ID number"). Description: "Get status of a specific task by name or number."

     - `get_task_result`: Get the output/result of a completed task. Parameters: `identifier` (string, "Task name, partial name, or ID number"), `tail_lines` (integer, optional, default 50, "Number of output lines to return from the end -- use fewer for quick summaries, more for detailed results"). Description: "Read a task's output. For completed tasks, summarizes what was accomplished. For running tasks, shows recent progress. Keep spoken summaries brief."

     - `cancel_task`: Cancel a running task immediately. Parameters: `identifier` (string, "Task name, partial name, or ID number"). Description: "Cancel a running task. No confirmation needed -- just do it."

  3. Add `self.task_manager = TaskManager()` in LiveSession.__init__ (after the existing attribute initializations).

  4. Update the session.update call in LiveSession.connect() (line 96-113):
     - Change `"tools": []` to `"tools": TASK_TOOLS`
     - Change `"tool_choice": "none"` to `"tool_choice": "auto"`

  5. Add a `_resolve_task` helper method to LiveSession:
     ```python
     def _resolve_task(self, identifier: str) -> ClaudeTask | None:
         """Resolve a task identifier (name or ID) to a ClaudeTask."""
         # Try as integer ID first
         try:
             task_id = int(identifier)
             return self.task_manager.get_task(task_id)
         except ValueError:
             pass
         # Try name match
         return self.task_manager.find_task_by_name(identifier)
     ```

  6. Add an async `_execute_tool` method to LiveSession that handles each tool:

     - `spawn_task`: Extract name, prompt, project_dir from args. Call `await self.task_manager.spawn_task(name, prompt, Path(project_dir))`. Return JSON with task id, name, status. Catch ValueError (project already has a running task) and return error JSON.

     - `list_tasks`: Call `self.task_manager.get_all_tasks()`. Build a list of dicts with id, name, status, duration (if completed: "completed in X.Xs", if running: "running for X.Xs", if pending: "pending"). Return JSON array.

     - `get_task_status`: Call `self._resolve_task(identifier)`. If not found, return error JSON. Otherwise return JSON with id, name, status, project_dir, duration info, and last 5 lines of output as "recent_output".

     - `get_task_result`: Call `self._resolve_task(identifier)`. If not found, return error JSON. Get output via `self.task_manager.get_task_output(task.id)`. Split into lines, take last `tail_lines` lines. Return JSON with id, name, status, output (the tail), total_lines.

     - `cancel_task`: Call `self._resolve_task(identifier)`. If not found, return error JSON. Call `await self.task_manager.cancel_task(task.id)`. Return JSON with success boolean and message.

     All tool returns must be `json.dumps(result_dict)`.

  7. Add function_call handling to the `response.done` event handler in handle_events(). After the existing conversation history tracking block (around line 279-293), add function_call detection. Follow the proven pattern from openai_realtime.py lines 363-399:

     ```python
     for item in output_items:
         if item.get("type") == "function_call":
             call_id = item.get("call_id")
             name = item.get("name")
             arguments = item.get("arguments", "{}")
             print(f"Live session: Tool call - {name}({arguments})", flush=True)

             # Execute tool asynchronously
             try:
                 args = json.loads(arguments)
                 result = await self._execute_tool(name, args)
             except Exception as e:
                 result = json.dumps({"error": str(e)})

             # Send result back to conversation
             await self.ws.send(json.dumps({
                 "type": "conversation.item.create",
                 "item": {
                     "type": "function_call_output",
                     "call_id": call_id,
                     "output": result
                 }
             }))

             # Trigger AI to respond with the result
             await self.ws.send(json.dumps({
                 "type": "response.create"
             }))
     ```

     IMPORTANT: The function_call handling must happen BEFORE the existing `maybe_summarize()` call and BEFORE the fallback unmute logic. When a function_call is processed, the response.create triggers a new response cycle, so we should NOT unmute or summarize yet -- those will happen when the final (non-tool-call) response.done fires. Add a flag: if any function_call was processed, skip the summarize and fallback_unmute for this response.done event.

  8. Add a `_notification_queue` list attribute in __init__ (empty list). This will be used by Plan 02 for queuing task completion notifications. Just initialize it now: `self._notification_queue = []`.
  </action>
  <verify>
  - `python -c "from live_session import LiveSession, TASK_TOOLS; print(f'{len(TASK_TOOLS)} tools defined'); ls = LiveSession.__init__; print('OK')"` prints "5 tools defined" and "OK"
  - `python -c "from live_session import TASK_TOOLS; names = [t['name'] for t in TASK_TOOLS]; assert names == ['spawn_task', 'list_tasks', 'get_task_status', 'get_task_result', 'cancel_task'], f'Got {names}'; print('All tools present')"` passes
  - `python -c "from live_session import LiveSession; ls = LiveSession('fake-key'); assert hasattr(ls, 'task_manager'); assert hasattr(ls, '_notification_queue'); assert hasattr(ls, '_resolve_task'); assert hasattr(ls, '_execute_tool'); print('All attributes and methods present')"` passes
  - `grep -n 'TASK_TOOLS' live_session.py` shows tool definitions referenced in both module-level constant and session.update
  - `grep -n 'function_call' live_session.py` shows function_call handling in response.done handler
  - `grep -n 'tool_choice.*auto' live_session.py` confirms tools are enabled
  </verify>
  <done>
  LiveSession has 5 task management tools registered with the Realtime API session, a function_call handler that routes tool calls to TaskManager methods, and proper flow control that skips unmute/summarize during tool call cycles. The AI can now invoke spawn_task, list_tasks, get_task_status, get_task_result, and cancel_task in response to user voice requests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend system prompt with task orchestrator personality</name>
  <files>personality/context.md, push-to-talk.py</files>
  <action>
  1. Replace the content of `personality/context.md` with task orchestrator instructions. This file is loaded as part of the system prompt via _build_personality(). Write:

     ```
     # Task Orchestrator

     You can manage background tasks using your tools. Tasks are Claude CLI processes that do real work -- coding, refactoring, debugging, file analysis -- in project directories.

     ## Core Principle

     You are a conversation partner first, task manager second. Task management should feel like a natural part of conversation, not a separate mode.

     ## When to Spawn Tasks

     Use spawn_task when the user asks you to do real work that requires code changes, file operations, or deep analysis. Use your judgment -- if someone says "can you refactor the auth module", that is a task. If someone asks "what does the auth module do", that is a question you answer yourself.

     ## Spoken Responses

     Remember every word you say takes real time to speak. Be brief:
     - Task spawned: "On it." or "Started." or a one-line acknowledgment.
     - Status query: Name and status of each task, nothing more.
     - Results: One to three sentence summary of what was accomplished. Skip implementation details unless asked.
     - Cancel: "Done." or "Cancelled."

     ## Task Names

     Generate short descriptive names from the request. Two to four words. Examples: "auth refactor", "fix tests", "add logging", "database migration".

     ## Referring to Tasks

     Users may refer to tasks by name, partial name, number, or description. Accept whatever is natural. If ambiguous, ask which one they mean.

     ## Project Directories

     When the user mentions a project, use the absolute path. If you do not know the path, ask. Learn project locations over the session -- if someone says "the push-to-talk project" and you spawned a task there before, use the same path.
     ```

  2. In push-to-talk.py, find the `start_live_session` method (line 879). After the LiveSession is created (line 893-897), add TaskManager initialization to ensure it is ready:

     ```python
     # Ensure TaskManager singleton is initialized for this session
     from task_manager import TaskManager
     TaskManager()  # Initialize singleton if not already
     ```

     This is a safety measure -- TaskManager() is also called in LiveSession.__init__, but having it here makes the dependency explicit in the orchestration layer.
  </action>
  <verify>
  - `python -c "from live_session import LiveSession; ls = LiveSession('fake-key'); assert 'Task Orchestrator' in ls.personality_prompt; assert 'spawn_task' in ls.personality_prompt; print('Personality loaded with task orchestrator instructions')"` passes
  - `grep -q 'conversation partner first' personality/context.md && echo 'Core principle present'` outputs "Core principle present"
  - `grep -q 'TaskManager' push-to-talk.py && echo 'TaskManager imported in push-to-talk.py'` passes
  </verify>
  <done>
  The AI personality includes task orchestrator instructions that establish the "conversation first, task management second" principle, guide task naming, set response brevity expectations for spoken output, and teach the AI when to spawn tasks vs answer questions directly. push-to-talk.py explicitly initializes TaskManager during live session startup.
  </done>
</task>

</tasks>

<verification>
- All 5 task tools (spawn_task, list_tasks, get_task_status, get_task_result, cancel_task) are defined in TASK_TOOLS and sent in session.update
- Function call handler in response.done correctly routes to _execute_tool and sends function_call_output + response.create
- TaskManager singleton is imported and used in LiveSession
- _resolve_task handles both integer IDs and name-based lookup
- Tool calls do not block the event loop (all TaskManager calls are fast in-memory lookups except spawn_task which returns immediately)
- System prompt includes task orchestrator personality with brevity guidelines
- response.done handler skips summarize/unmute when processing function_calls (prevents premature mic unmute during tool call cycles)
</verification>

<success_criteria>
1. `python -c "from live_session import LiveSession, TASK_TOOLS; print(len(TASK_TOOLS))"` prints 5
2. LiveSession.__init__ creates a TaskManager instance
3. session.update sends tools with tool_choice "auto"
4. response.done handler detects function_call items and routes to _execute_tool
5. _execute_tool handles all 5 tool names and returns JSON results
6. personality/context.md contains task orchestrator instructions
7. No new dependencies added (all stdlib + existing modules)
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-controlled-task-orchestration/03-01-SUMMARY.md`
</output>
