---
phase: 03-voice-controlled-task-orchestration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - live_session.py
  - push-to-talk.py
autonomous: false

must_haves:
  truths:
    - "When a task completes, the user hears a spoken summary of the outcome without interrupting active conversation"
    - "When a task fails, the user hears a spoken error summary"
    - "The AI knows what tasks are running at all times without being asked (ambient awareness)"
    - "The AI auto-generates short descriptive names for tasks"
    - "Task notifications wait for a natural pause before being delivered"
  artifacts:
    - path: "live_session.py"
      provides: "Task completion/failure callback handlers, notification queue, notification flush logic"
      contains: "_on_task_complete"
    - path: "live_session.py"
      provides: "Ambient task status injection into conversation context"
      contains: "_inject_task_context"
  key_links:
    - from: "task_manager.py (on_task_complete callback)"
      to: "live_session.py (_on_task_complete)"
      via: "TaskManager.on() callback registration"
      pattern: "self\\.task_manager\\.on\\('on_task_complete'"
    - from: "live_session.py (_flush_notifications)"
      to: "WebSocket (conversation.item.create + response.create)"
      via: "Notification queue drain into conversation"
      pattern: "conversation\\.item\\.create"
    - from: "live_session.py (response.done handler)"
      to: "live_session.py (_flush_notifications)"
      via: "Check and flush pending notifications after each response cycle completes"
      pattern: "_flush_notifications"
---

<objective>
Add task completion/failure notifications, notification queuing, and ambient task awareness to LiveSession so the AI proactively reports task outcomes and always knows what tasks are running.

Purpose: Without notifications, users must manually poll for task status. The AI should proactively inform users when tasks finish or fail, waiting for a natural pause in conversation to avoid interrupting. Ambient awareness means the AI can weave task status into conversation naturally.

Output: LiveSession with callback-driven task notifications that queue when the AI is speaking and flush during natural pauses, plus ambient task context injection that keeps the AI informed of running task state.
</objective>

<execution_context>
@/home/ethan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ethan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-voice-controlled-task-orchestration/03-RESEARCH.md
@.planning/phases/03-voice-controlled-task-orchestration/03-01-SUMMARY.md
@live_session.py
@task_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add task notification callbacks and queue-based delivery</name>
  <files>live_session.py</files>
  <action>
  1. In LiveSession.__init__, after the `self._notification_queue = []` line (added by Plan 01), add callback registration:

     ```python
     # Register task lifecycle callbacks
     self.task_manager.on('on_task_complete', self._on_task_complete)
     self.task_manager.on('on_task_failed', self._on_task_failed)
     ```

  2. Add `_on_task_complete` method to LiveSession:

     ```python
     async def _on_task_complete(self, task):
         """Handle task completion -- queue notification for delivery."""
         if not self.running or not self.ws:
             return
         duration = (task.completed_at or time.time()) - (task.started_at or task.created_at)
         # Get last few lines of output for summary context
         output_tail = '\n'.join(list(task.output_lines)[-20:])
         notification = {
             "type": "task_complete",
             "task_id": task.id,
             "task_name": task.name,
             "duration": f"{duration:.1f}s",
             "output_summary": output_tail[:1500],
             "project_dir": str(task.project_dir)
         }
         self._notification_queue.append(notification)
         print(f"Live session: Queued completion notification for task {task.id} '{task.name}'", flush=True)

         # If not currently speaking, flush immediately
         if not self.playing_audio:
             await self._flush_notifications()
     ```

  3. Add `_on_task_failed` method to LiveSession:

     ```python
     async def _on_task_failed(self, task):
         """Handle task failure -- queue notification for delivery."""
         if not self.running or not self.ws:
             return
         duration = (task.completed_at or time.time()) - (task.started_at or task.created_at)
         output_tail = '\n'.join(list(task.output_lines)[-20:])
         notification = {
             "type": "task_failed",
             "task_id": task.id,
             "task_name": task.name,
             "duration": f"{duration:.1f}s",
             "exit_code": task.return_code,
             "error_output": output_tail[:1500],
             "project_dir": str(task.project_dir)
         }
         self._notification_queue.append(notification)
         print(f"Live session: Queued failure notification for task {task.id} '{task.name}'", flush=True)

         if not self.playing_audio:
             await self._flush_notifications()
     ```

  4. Add `_flush_notifications` method to LiveSession:

     ```python
     async def _flush_notifications(self):
         """Deliver any queued task notifications to the conversation."""
         if not self._notification_queue or not self.ws or not self.running:
             return

         # Drain the queue
         notifications = self._notification_queue[:]
         self._notification_queue.clear()

         for notification in notifications:
             notif_type = notification["type"]
             task_name = notification["task_name"]

             if notif_type == "task_complete":
                 message = (
                     f"[Task notification] Task '{task_name}' (ID {notification['task_id']}) "
                     f"completed successfully in {notification['duration']}. "
                     f"Project: {notification['project_dir']}. "
                     f"Output summary:\n{notification['output_summary']}\n\n"
                     f"Inform the user briefly that this task finished. One or two sentences max."
                 )
             elif notif_type == "task_failed":
                 message = (
                     f"[Task notification] Task '{task_name}' (ID {notification['task_id']}) "
                     f"failed after {notification['duration']} with exit code {notification['exit_code']}. "
                     f"Project: {notification['project_dir']}. "
                     f"Error output:\n{notification['error_output']}\n\n"
                     f"Inform the user briefly that this task failed and what went wrong. Keep it short."
                 )
             else:
                 continue

             print(f"Live session: Delivering notification for task '{task_name}'", flush=True)

             # Inject as system message so AI can speak about it
             await self.ws.send(json.dumps({
                 "type": "conversation.item.create",
                 "item": {
                     "type": "message",
                     "role": "system",
                     "content": [{"type": "input_text", "text": message}]
                 }
             }))

             # Trigger AI to speak the notification
             await self.ws.send(json.dumps({
                 "type": "response.create"
             }))
     ```

  5. In the `response.done` event handler in handle_events(), add notification flushing. After the existing response.done logic (summarize, fallback_unmute), add a call to flush pending notifications. This should happen ONLY when no function_calls were processed in this response cycle (use the flag from Plan 01):

     ```python
     # After the existing response.done logic, if no function calls were processed:
     if not had_function_calls and self._notification_queue:
         # Small delay to let audio finish before delivering notification
         async def delayed_flush():
             await asyncio.sleep(1.5)
             if not self.playing_audio:
                 await self._flush_notifications()
         asyncio.create_task(delayed_flush())
     ```

  6. In LiveSession.disconnect(), add callback cleanup. Before the existing cleanup code, deregister or note that callbacks will naturally become no-ops since we check self.running and self.ws at the top of each callback handler.

  7. Add `_inject_task_context` method for ambient awareness. This builds a brief status string of active tasks and injects it as context that the AI can reference:

     ```python
     async def _inject_task_context(self):
         """Inject current task status into conversation for ambient awareness."""
         if not self.ws or not self.running:
             return
         running = self.task_manager.get_running_tasks()
         recent_completed = [
             t for t in self.task_manager.get_all_tasks()
             if t.status in (TaskStatus.COMPLETED, TaskStatus.FAILED)
             and t.completed_at and (time.time() - t.completed_at) < 300  # last 5 min
         ]

         if not running and not recent_completed:
             return

         parts = []
         if running:
             task_strs = [f"'{t.name}' (running {time.time() - (t.started_at or t.created_at):.0f}s)" for t in running]
             parts.append(f"Running tasks: {', '.join(task_strs)}")
         if recent_completed:
             task_strs = [f"'{t.name}' ({t.status.value})" for t in recent_completed[:3]]
             parts.append(f"Recently finished: {', '.join(task_strs)}")

         context = "[Background task status] " + ". ".join(parts)

         await self.ws.send(json.dumps({
             "type": "conversation.item.create",
             "item": {
                 "type": "message",
                 "role": "system",
                 "content": [{"type": "input_text", "text": context}]
             }
         }))
     ```

  8. Call `_inject_task_context()` from the `input_audio_buffer.speech_stopped` event handler (line 323-329 area). When the user stops speaking, inject task context before the AI formulates its response. This way the AI is aware of running tasks when responding:

     ```python
     # After existing speech_stopped logic:
     await self._inject_task_context()
     ```

     This is lightweight -- if no tasks are running or recently completed, it returns immediately. If tasks exist, a brief system message is injected giving the AI ambient awareness.
  </action>
  <verify>
  - `python -c "from live_session import LiveSession; ls = LiveSession('fake-key'); assert hasattr(ls, '_on_task_complete'); assert hasattr(ls, '_on_task_failed'); assert hasattr(ls, '_flush_notifications'); assert hasattr(ls, '_inject_task_context'); print('All notification methods present')"` passes
  - `grep -n '_on_task_complete\|_on_task_failed\|_flush_notifications\|_inject_task_context' live_session.py` shows all 4 methods defined
  - `grep -n "on_task_complete\|on_task_failed" live_session.py` shows callback registration in __init__
  - `grep -n '_notification_queue' live_session.py` shows queue usage in multiple locations (init, callbacks, flush, response.done)
  - `grep -n 'speech_stopped' live_session.py` shows _inject_task_context call in the speech_stopped handler
  </verify>
  <done>
  Task completion and failure notifications are delivered as spoken summaries via the conversation. Notifications queue when the AI is speaking and flush during natural pauses (after response.done or after delayed_flush). Ambient task awareness injects running task status before each AI response so the AI always knows what tasks are active. The AI can proactively mention task status when conversationally relevant.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
  Complete voice-controlled task orchestration system:
  - 5 task management tools (spawn, list, status, result, cancel) wired into LiveSession
  - Function call handler routes tool calls to TaskManager
  - Task completion/failure notifications delivered as spoken summaries
  - Notifications queue during active speech and flush at natural pauses
  - Ambient task awareness injects running task context before AI responses
  - Task orchestrator personality in system prompt
  </what-built>
  <how-to-verify>
  1. Start the push-to-talk service and enter live mode
  2. Test task spawning: Say "ask Claude to create a hello world Python script in /tmp/test-project" -- AI should acknowledge briefly and continue conversation
  3. Test status query: Say "what are my tasks doing?" -- AI should report the running task
  4. Wait for task completion -- AI should proactively tell you it finished
  5. Test result retrieval: Say "what did that task produce?" -- AI should summarize the output
  6. Test another spawn + cancel: Spawn a long-running task, then say "cancel that task" -- it should terminate immediately
  7. Verify conversation continues naturally throughout -- no blocking, no long pauses during tool execution
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
- TaskManager callbacks fire on task completion/failure and queue notifications
- Notifications flush when AI is not speaking (natural pause delivery)
- Ambient task awareness injects context before each AI response
- No blocking operations in notification path
- Session disconnect is clean (callbacks become no-ops via running/ws checks)
- Notification messages instruct AI to be brief (1-2 sentences)
</verification>

<success_criteria>
1. Task completion triggers a spoken notification without user prompting
2. Task failure triggers a spoken error notification
3. Notifications wait for natural pauses -- no interruption of active AI speech
4. AI mentions running tasks when conversationally relevant (ambient awareness)
5. Full flow works: spawn -> status -> completion notification -> result retrieval
6. Multiple concurrent tasks tracked and reported independently
</success_criteria>

<output>
After completion, create `.planning/phases/03-voice-controlled-task-orchestration/03-02-SUMMARY.md`
</output>
