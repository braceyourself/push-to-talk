---
phase: 06-polish-verification
plan: 03
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - indicator.py
autonomous: false

must_haves:
  truths:
    - "Tool-use overlay shows AI-summarized intent (e.g., 'Starting a task') instead of generic 'Using Tool'"
    - "Status history shows tool intents instead of bare 'Using Tool' entries"
    - "Consecutive tool_use entries in history are coalesced into a single evolving entry"
    - "All overlay status states (listening, thinking, tool_use, speaking, idle, muted) render correctly"
    - "Status history panel shows transitions with timestamps"
  artifacts:
    - path: "indicator.py"
      provides: "JSON status parsing, tool intent rendering, history coalescing"
      contains: "tool_intent"
  key_links:
    - from: "indicator.py check_status"
      to: "indicator.py update_status"
      via: "JSON parsing extracts status + metadata, passes to update_status"
      pattern: "json.loads"
    - from: "indicator.py on_draw"
      to: "self.tool_intent"
      via: "Renders tool_intent text instead of static 'Using Tool' label"
      pattern: "tool_intent"
---

<objective>
Update the LiveOverlayWidget to parse JSON status metadata, display dynamic tool intent labels, coalesce consecutive tool entries in history, and verify all overlay states render correctly.

Purpose: The overlay currently shows a generic "Using Tool" label during tool use. With tool intent metadata from Plan 02, it can show what the AI is actually doing ("Starting a task", "Checking task progress"). History enrichment makes the status panel more informative. This is the final integration point for the richer status system.

Output: Dynamic tool-use overlay with intent labels, enriched history, JSON status parsing.
</objective>

<execution_context>
@/home/ethan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ethan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-polish-verification/06-RESEARCH.md
@.planning/phases/06-polish-verification/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: JSON status parsing and dynamic tool intent overlay</name>
  <files>indicator.py</files>
  <action>
  Three changes to LiveOverlayWidget in indicator.py:

  **A. Parse JSON status in check_status** (the module-level `check_status` function around line 2206):

  The status file now may contain either a plain string ("listening") or a JSON object ({"status": "tool_use", "intent": "Starting a task"}). Update the check_status function to detect and parse JSON:

  ```python
  # In check_status() (around line 2218-2224):
  if STATUS_FILE.exists():
      content = STATUS_FILE.read_text().strip()
      if content.startswith('{'):
          try:
              import json
              data = json.loads(content)
              status = data.get('status', 'idle')
              metadata = data
          except (json.JSONDecodeError, ValueError):
              status = content
              metadata = None
      else:
          status = content
          metadata = None

      # Don't override user-set muted status
      if _live_overlay.status == 'muted' and status != 'muted':
          pass
      else:
          _live_overlay.update_status(status, metadata)
  ```

  **B. Update `update_status` to accept metadata** (around line 2027):

  ```python
  def update_status(self, status, metadata=None):
      """Update the displayed status with optional metadata."""
      # Handle stt_rejected flash (from Plan 01)
      if status == 'stt_rejected':
          self._flash_rejection()
          return

      # Extract tool intent from metadata
      if status == 'tool_use' and metadata and 'intent' in metadata:
          self.tool_intent = metadata['intent']
      elif status != 'tool_use':
          self.tool_intent = None

      if status != self.status or (status == 'tool_use' and self.tool_intent):
          timestamp = time.strftime("%H:%M:%S")

          # Coalesce consecutive tool_use entries in history
          if (status == 'tool_use' and self.status_history
                  and self.status_history[-1][1].startswith('tool_use')):
              # Update the last entry instead of appending
              display = f"tool_use: {self.tool_intent}" if self.tool_intent else "tool_use"
              self.status_history[-1] = (timestamp, display)
          else:
              display = f"tool_use: {self.tool_intent}" if (status == 'tool_use' and self.tool_intent) else status
              self.status_history.append((timestamp, display))
              if len(self.status_history) > 50:
                  self.status_history = self.status_history[-50:]

      self.status = status
      self._resize_window()
      self.queue_draw()
  ```

  **C. Initialize `tool_intent`** in `__init__` (around line 1863, after `self.expanded = False`):
  ```python
  self.tool_intent = None
  ```

  **D. Render tool intent in on_draw** (around line 1964-1970):

  When status is `tool_use` and `tool_intent` is set, show the intent text instead of the generic "Using Tool" label:

  ```python
  # Draw status text
  if self.status == 'tool_use' and self.tool_intent:
      label = self.tool_intent
  else:
      label = self.STATUS_LABELS.get(self.status, self.status.title())
  ```

  **E. Render enriched history entries** (around line 2001-2023):

  History entries now store "tool_use: Checking tasks" instead of bare "tool_use". Update the history rendering to handle this format:

  ```python
  for ts, st in entries:
      # Parse enriched status (may be "tool_use: intent text")
      if ': ' in st and st.startswith('tool_use'):
          base_status = 'tool_use'
          display_label = st.split(': ', 1)[1]
      else:
          base_status = st
          display_label = self.STATUS_LABELS.get(st, st.title())

      # Small colored dot
      dc = self.DOT_COLORS.get(base_status, self.DOT_COLORS['idle'])
      cr.set_source_rgba(dc[0], dc[1], dc[2], 0.9)
      cr.arc(18, row_y + self.HISTORY_ROW_HEIGHT / 2, 3.5, 0, 2 * PI)
      cr.fill()

      # Timestamp
      cr.set_source_rgba(0.55, 0.55, 0.55, 1.0)
      cr.select_font_face("Sans", 0, 0)
      cr.set_font_size(11)
      cr.move_to(28, row_y + self.HISTORY_ROW_HEIGHT / 2 + 4)
      cr.show_text(ts)

      # Label — truncate long intent labels
      cr.set_source_rgba(0.75, 0.75, 0.75, 1.0)
      cr.move_to(82, row_y + self.HISTORY_ROW_HEIGHT / 2 + 4)
      cr.show_text(display_label[:20])  # Truncate to fit overlay width

      row_y += self.HISTORY_ROW_HEIGHT
  ```

  Also truncate the main label in the header area to prevent overflow. Add after the label assignment:
  ```python
  # Truncate to fit overlay width (main header)
  if len(label) > 18:
      label = label[:17] + "..."
  ```
  </action>
  <verify>
  Run `python -c "import ast; ast.parse(open('indicator.py').read()); print('syntax ok')"` to verify no syntax errors.
  Grep for `tool_intent` in indicator.py to confirm the attribute and rendering logic exist.
  Grep for `json.loads` in indicator.py to confirm JSON parsing in check_status.
  Grep for `coalesce\|Coalesce\|consecutive` in indicator.py to confirm history coalescing comment exists.
  </verify>
  <done>Overlay parses JSON status metadata, displays dynamic tool intent labels during tool_use, coalesces consecutive tool entries in history, and renders enriched history with intent text.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: End-to-end verification of all overlay states</name>
  <what-built>
  Complete Phase 6 implementation across 3 plans:
  - Plan 01: Multi-layer Whisper filtering (no_speech_prob + logprob + compression_ratio), STT rejection flash
  - Plan 02: Acknowledgment clip pool, gated pre-tool playback, tool intent map, JSON status metadata
  - Plan 03: Dynamic tool-use overlay with intent labels, enriched history, JSON parsing

  All overlay states should now work correctly: listening, thinking, tool_use (with intent), speaking, idle, muted. Status history shows rich tool intent entries.
  </what-built>
  <how-to-verify>
  Start a live session and verify each state:

  1. **Listening state**: Press AI hotkey — overlay shows green dot + "Listening"
  2. **Thinking state**: Speak a question, release — overlay shows yellow dot + "Thinking"
  3. **Tool-use state**: Ask Claude to do something that triggers a tool (e.g., "check on my tasks") — overlay should show orange dot + dynamic intent label (e.g., "Checking tasks"), NOT generic "Using Tool"
  4. **Acknowledgment clip**: During tool use, you should hear a brief verbal phrase like "one sec" or "let me check" before the tool runs (only if tool takes >300ms)
  5. **Speaking state**: When AI responds — overlay shows blue dot + "Speaking"
  6. **Muted state**: Right-click overlay -> Mute — shows orange dot + "Muted"
  7. **STT rejection flash**: Clear your throat or cough while in listening state — dot should briefly dim (300ms flash), and the console should show "STT: Rejected (logprob=...)" logs
  8. **Status history**: Click the overlay to expand history panel — should show timestamps and state transitions, with tool intents shown as descriptive labels (e.g., "Checking tasks")
  9. **History coalescing**: If multiple tool calls happen in sequence, they should appear as a single evolving entry in history, not multiple separate entries
  10. **Idle state**: After AI finishes speaking and silence timeout — gray dot + "Idle"
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
1. `python -c "import ast; ast.parse(open('indicator.py').read()); print('ok')"` — no syntax errors
2. Grep confirms: tool_intent, json.loads, consecutive/coalesce in indicator.py
3. Manual testing of all 6 status states (listening, thinking, tool_use, speaking, idle, muted) plus stt_rejected flash
</verification>

<success_criteria>
- Tool-use overlay shows AI-summarized intent (not generic "Using Tool")
- Status history shows rich tool intent labels
- Consecutive tool_use entries are coalesced into single evolving entry
- All 6 status states render with correct colors and labels
- STT rejection flash works (dot dims briefly on filtered audio)
- History panel expands/collapses on click with correct entries
</success_criteria>

<output>
After completion, create `.planning/phases/06-polish-verification/06-03-SUMMARY.md`
</output>
