---
phase: 12-infrastructure-safety-net
plan: 03
type: tdd
wave: 2
depends_on: ["12-01"]
files_modified:
  - deepgram_stt.py
  - test_deepgram_stt.py
autonomous: true

must_haves:
  truths:
    - "Transcripts matching recent AI speech are filtered as echo (not passed to pipeline)"
    - "Echo filtering uses fuzzy matching with timing window (not exact string comparison)"
    - "Playback-aware suppression extends beyond playback end by configurable cooldown"
    - "Non-echo transcripts during playback cooldown are preserved (not blindly dropped)"
  artifacts:
    - path: "deepgram_stt.py"
      provides: "Echo suppression via transcript fingerprinting in _emit_transcript()"
      contains: "_spoken_sentences"
    - path: "test_deepgram_stt.py"
      provides: "Echo suppression tests"
      min_lines: 200
  key_links:
    - from: "deepgram_stt.py"
      to: "live_session.py"
      via: "_spoken_sentences list fed by playback stage"
      pattern: "_spoken_sentences|set_recent_ai_speech"
---

<objective>
Add echo suppression via transcript fingerprinting to DeepgramSTT.

Purpose: PipeWire AEC is the primary echo cancellation layer, but residual echo can leak through -- especially with cloud STT where network latency widens the timing window. Transcript fingerprinting against recent AI speech provides defense-in-depth. This prevents the system from transcribing its own speech and creating feedback loops. (Pitfall 5 from research)

Output: DeepgramSTT gains `set_recent_ai_speech()` method and internal fingerprinting logic. Tests validate echo filtering with various match scenarios.
</objective>

<execution_context>
@/home/ethan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ethan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/research/PITFALLS.md — Pitfall 5 (echo cancellation feedback loop), detailed mitigations
@.planning/research/ARCHITECTURE.md — Echo handling design, _spoken_sentences integration
@deepgram_stt.py — From Plan 01 (must exist before this plan runs)
@test_deepgram_stt.py — From Plan 01 (add echo tests to existing file)
@live_session.py — Lines 277-278: _spoken_sentences list (already tracks AI speech)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write echo suppression tests</name>
  <files>test_deepgram_stt.py</files>
  <action>
Add echo suppression tests to the existing test_deepgram_stt.py file (from Plan 01).

**New test cases (RED phase):**

1. **test_echo_exact_match_filtered**: Set recent AI speech to ["Hello, how can I help you?"]. Send a speech_final with text "Hello, how can I help you?". Verify it is filtered (not emitted to TranscriptBuffer).

2. **test_echo_fuzzy_match_filtered**: Set recent AI speech to ["I'd be happy to help with that"]. Send a speech_final with text "I'd be happy to help with" (partial match). Verify it is filtered. Use a similarity threshold (e.g., 80% match ratio).

3. **test_echo_case_insensitive**: Set recent AI speech to ["The answer is forty-two"]. Send "the answer is forty two" (different case, different hyphenation). Verify filtered.

4. **test_non_echo_not_filtered**: Set recent AI speech to ["The weather is nice today"]. Send "Can you check my calendar?". Verify it passes through (NOT filtered).

5. **test_echo_timing_window**: Set recent AI speech at time T. Advance time by 10 seconds (beyond timing window). Send matching text. Verify it passes through (echo window expired).

6. **test_echo_during_playback_suppressed**: Set playing_audio=True. Send text matching AI speech. Verify suppressed by BOTH playback gating AND echo filtering (belt and suspenders).

7. **test_set_recent_ai_speech_updates_buffer**: Call `set_recent_ai_speech(["sentence1", "sentence2"])`. Verify internal echo buffer is updated. Call again with new sentences. Verify old sentences are replaced.

**Mock strategy:**
- Use `time.time()` patching to control timing windows
- Real TranscriptBuffer (no mocking needed)
- Test the `_is_echo()` method directly if it's a separate method
  </action>
  <verify>python3 test_deepgram_stt.py — new echo tests fail (methods don't exist yet), old tests still pass</verify>
  <done>7 new echo suppression test cases exist in test_deepgram_stt.py, all initially failing</done>
</task>

<task type="auto">
  <name>Task 2: Implement echo suppression in DeepgramSTT</name>
  <files>deepgram_stt.py</files>
  <action>
Add transcript fingerprinting to DeepgramSTT to filter echoed AI speech.

**New public method:**
```python
def set_recent_ai_speech(self, sentences: list[str]):
    """Update the echo fingerprint buffer with recent AI speech.

    Called by LiveSession when TTS sentences are sent to playback.
    Used for defense-in-depth echo filtering alongside PipeWire AEC.
    """
    self._echo_fingerprints = [
        (s.lower().strip(), time.time()) for s in sentences
    ]
```

**Echo detection logic in `_emit_transcript()`:**
Add echo check BEFORE the existing hallucination filter:

```python
def _is_echo(self, text: str) -> bool:
    """Check if transcript matches recent AI speech (echo leak through AEC).

    Uses fuzzy substring matching with timing window. A transcript is
    considered echo if:
    1. It was spoken by the AI within the last ECHO_WINDOW_SECONDS
    2. The normalized text similarity exceeds ECHO_SIMILARITY_THRESHOLD

    Returns True if the text is likely echo.
    """
    if not self._echo_fingerprints:
        return False

    now = time.time()
    normalized = text.lower().strip()

    for ai_text, timestamp in self._echo_fingerprints:
        # Check timing window
        if now - timestamp > ECHO_WINDOW_SECONDS:
            continue

        # Check similarity (use SequenceMatcher for fuzzy matching)
        from difflib import SequenceMatcher
        ratio = SequenceMatcher(None, normalized, ai_text).ratio()
        if ratio > ECHO_SIMILARITY_THRESHOLD:
            return True

        # Also check if transcript is a substring of AI speech
        if len(normalized) > 5 and normalized in ai_text:
            return True

    return False
```

**Constants:**
```python
ECHO_WINDOW_SECONDS = 5.0       # How long to remember AI speech for echo detection
ECHO_SIMILARITY_THRESHOLD = 0.7  # SequenceMatcher ratio threshold
```

**Integration in _emit_transcript():**
```python
def _emit_transcript(self, text):
    # Playback suppression (existing)
    if self._playing_audio:
        return
    if time.time() - self._playback_end_time < self._PLAYBACK_COOLDOWN:
        return

    # Echo suppression (NEW)
    if self._is_echo(text):
        print(f"DeepgramSTT: Filtered echo: \"{text[:40]}\"", flush=True)
        return

    # Hallucination filter (existing)
    if is_hallucination(text):
        ...
```

**Cleanup stale fingerprints:**
In `_maybe_emit_stats()` or `_emit_transcript()`, periodically clean old entries:
```python
self._echo_fingerprints = [
    (t, ts) for t, ts in self._echo_fingerprints
    if time.time() - ts < ECHO_WINDOW_SECONDS * 2
]
```
  </action>
  <verify>python3 test_deepgram_stt.py — all tests pass (both old and new echo tests)</verify>
  <done>Echo suppression works via transcript fingerprinting. All tests pass.</done>
</task>

</tasks>

<verification>
1. `python3 test_deepgram_stt.py` -- all tests pass (original + echo tests)
2. `grep 'set_recent_ai_speech' deepgram_stt.py` -- method exists
3. `grep '_is_echo' deepgram_stt.py` -- echo detection method exists
4. `grep 'ECHO_WINDOW_SECONDS' deepgram_stt.py` -- constant defined
</verification>

<success_criteria>
DeepgramSTT filters transcripts that match recent AI speech using fuzzy matching within a timing window. This provides defense-in-depth echo suppression alongside PipeWire AEC. All tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/12-infrastructure-safety-net/12-03-SUMMARY.md`
</output>
