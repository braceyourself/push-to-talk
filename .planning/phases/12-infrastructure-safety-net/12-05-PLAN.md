---
phase: 12-infrastructure-safety-net
plan: 05
type: execute
wave: 3
depends_on: ["12-03", "12-04"]
files_modified:
  - test_live_session.py
  - test_deepgram_stt.py
  - docs/pipeline.html
autonomous: false

must_haves:
  truths:
    - "Full test suite passes: both test_live_session.py and test_deepgram_stt.py"
    - "Pipeline diagram reflects Deepgram streaming architecture"
    - "End-to-end pipeline with mocked Deepgram produces correct frame sequence"
  artifacts:
    - path: "test_live_session.py"
      provides: "Updated integration tests covering Deepgram pipeline path"
    - path: "test_deepgram_stt.py"
      provides: "Complete test suite for DeepgramSTT"
    - path: "docs/pipeline.html"
      provides: "Updated pipeline diagram showing Deepgram architecture"
  key_links:
    - from: "test_live_session.py"
      to: "live_session.py"
      via: "make_session() -> pipeline stage mocking"
      pattern: "make_session|DeepgramSTT"
---

<objective>
Finalize Phase 12 with integration tests, pipeline diagram update, and deployment verification.

Purpose: Ensure everything works together. Update the pipeline diagram to reflect the new architecture. Add integration-level tests that verify the full Deepgram pipeline path (mocked Deepgram -> _stt_stage -> _stt_out_q). Verify deployment with /ptt-deploy.

Output: Complete test coverage, updated docs, deployed and verified.
</objective>

<execution_context>
@/home/ethan/.claude/get-shit-done/workflows/execute-plan.md
@/home/ethan/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/12-infrastructure-safety-net/12-01-SUMMARY.md
@.planning/phases/12-infrastructure-safety-net/12-03-SUMMARY.md
@.planning/phases/12-infrastructure-safety-net/12-04-SUMMARY.md
@test_live_session.py — Existing tests
@test_deepgram_stt.py — DeepgramSTT tests (from Plans 01+03)
@docs/pipeline.html — Pipeline diagram to update
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add integration tests for Deepgram pipeline path</name>
  <files>test_live_session.py</files>
  <action>
Add new tests to test_live_session.py that verify the Deepgram integration path.

**New test cases:**

1. **test_deepgram_stt_instantiation**: Verify make_session() creates a session that would instantiate DeepgramSTT (mock the import). Check that `deepgram_api_key` is stored on the session.

2. **test_stt_stage_consumes_transcript_queue**: Create a session, manually put a TranscriptSegment on `_deepgram_transcript_q`, verify _stt_stage emits END_OF_UTTERANCE + TRANSCRIPT frames to `_stt_out_q`.

3. **test_stt_stage_respects_mute**: Put a TranscriptSegment on queue while session.muted=True. Verify no frames emitted to _stt_out_q.

4. **test_stt_stage_respects_stt_gated**: Put a TranscriptSegment on queue while session._stt_gated=True. Verify no frames emitted to _stt_out_q.

5. **test_stt_stage_generation_id_tagging**: Verify emitted frames carry the correct generation_id from the session.

**Mock strategy for integration tests:**
- Mock DeepgramSTT to avoid real Deepgram connections
- Create `_deepgram_transcript_q` manually on the session
- Run `_stt_stage()` as an asyncio task for a short duration
- Put TranscriptSegments on the queue and check _stt_out_q output

**Update existing tests if needed:**
- If any existing tests reference ContinuousSTT directly, update them to work with DeepgramSTT
- The make_session() helper may need mock adjustments for the new import
  </action>
  <verify>python3 test_live_session.py — all tests pass (old and new)</verify>
  <done>Integration tests verify the Deepgram pipeline path in live_session.py</done>
</task>

<task type="auto">
  <name>Task 2: Update pipeline diagram and run full test suite</name>
  <files>docs/pipeline.html</files>
  <action>
**Update docs/pipeline.html** to reflect the new Deepgram streaming architecture:

1. Replace the "Stage 2: STT (Whisper)" box with "Stage 2: STT (Deepgram Consumer)"
2. Add a "DeepgramSTT" parallel stage box showing:
   - Audio Capture (pasimple) -> Silero VAD -> Deepgram WebSocket
   - Connection states: Active/Idle/Sleep
   - Output: TranscriptSegment -> transcript_q
3. Show the data flow: DeepgramSTT -> _deepgram_transcript_q -> _stt_stage -> _stt_out_q
4. Add the _barge_in_vad_stage as a parallel stage reading _audio_in_q
5. Keep downstream stages unchanged (LLM, Composer, Playback)
6. Add "Echo Suppression" as a filter layer in DeepgramSTT

**Run the full test suite:**
```bash
python3 test_live_session.py
python3 test_deepgram_stt.py
```

Both must pass with 0 failures.
  </action>
  <verify>
  - `python3 test_live_session.py` -- 0 failures
  - `python3 test_deepgram_stt.py` -- 0 failures
  - docs/pipeline.html is updated (check with grep for "Deepgram")
  </verify>
  <done>Pipeline diagram updated, full test suite passes</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Deepgram streaming STT infrastructure:
- DeepgramSTT class (deepgram_stt.py) with VAD lifecycle, WebSocket management, echo suppression
- Rewritten _stt_stage in live_session.py consuming Deepgram transcripts
- Barge-in VAD preserved in separate stage
- Full test coverage (test_deepgram_stt.py + test_live_session.py)
- Updated pipeline diagram
  </what-built>
  <how-to-verify>
1. Run `/ptt-deploy` to sync to the running service location
2. Start the push-to-talk service: `systemctl --user start push-to-talk`
3. Check journal for startup: `journalctl --user -u push-to-talk -f`
4. Verify you see "STT: Using Deepgram streaming" in logs
5. Verify you see "DeepgramSTT: Connected to Deepgram Nova-3" in logs
6. Speak naturally -- verify transcripts appear in logs ("STT [deepgram]: ...")
7. Verify Deepgram connection lifecycle:
   - Speak -> "active" mode (audio streaming)
   - Stay silent for ~10s -> logs show KeepAlive being sent
   - Speak again -> transcripts resume
8. Verify echo suppression: when AI speaks, verify AI speech does NOT appear as user transcripts
9. Verify barge-in still works: start AI response, speak to interrupt
10. Open pipeline diagram: `xdg-open docs/pipeline.html` -- verify it shows Deepgram architecture
  </how-to-verify>
  <resume-signal>Type "approved" if working, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `python3 test_live_session.py` -- 0 failures
2. `python3 test_deepgram_stt.py` -- 0 failures
3. Service starts with Deepgram STT and transcribes speech
4. Echo suppression filters AI speech from transcript stream
5. Barge-in detection works during AI playback
6. Connection lifecycle (active/idle) works as expected
7. Pipeline diagram reflects new architecture
</verification>

<success_criteria>
Phase 12 is complete when:
- All tests pass
- Service runs with Deepgram streaming STT
- User can speak naturally and see transcripts without pressing any button
- AI speech does not appear in transcript stream
- Deepgram connection lifecycle (active/idle) manages costs correctly
- Barge-in still works
- Network disconnection is handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/12-infrastructure-safety-net/12-05-SUMMARY.md`
</output>
